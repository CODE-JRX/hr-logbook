{% extends 'base.html' %}
{% block title %}Client Log â€” HR Logbook{% endblock %}

{% block content %}
<style>
	@keyframes scan {
		0% {
			top: 0;
		}

		100% {
			top: 100%;
		}
	}

	.modal,
	.modal-dialog {
		z-index: 9999 !important;
	}

	.modal-backdrop {
		display: none !important;
	}

	.modal-content {
		pointer-events: auto !important;
	}

	.modal-dialog {
		margin-top: 100px;
	}

	.client-log-container {
		display: flex;
		gap: 4px;
		align-items: flex-start;
		justify-content: center;
	}

	.camera-card {
		margin: 0;
		width: 460px;
		height: 460px;
		background: #0f1720;
		border-radius: 8px;
		border: 4px solid rgba(13, 110, 253, 0.12);
		display: flex;
		align-items: center;
		justify-content: center;
		position: relative;
	}

	.system-log-card {
		width: 320px;
		min-height: 460px;
		max-height: 460px;
		overflow: auto;
		border-radius: 8px;
		border: 4px solid rgba(0, 0, 0, 0.06);
		background: var(--card-bg);
		padding: 12px;
		color: var(--text-color);
	}

	.match-card {
		width: 320px;
		min-height: 460px;
		max-height: 460px;
		overflow: auto;
		border-radius: 8px;
		border: 4px solid rgba(0, 0, 0, 0.06);
		background: var(--card-bg);
		padding: 12px;
		color: var(--text-color);
	}

	@media (max-width: 767px) {
		.client-log-container {
			flex-direction: column;
			gap: 16px;
		}

		.camera-card {
			width: 100%;
			height: auto;
			min-height: 300px;
		}

		.system-log-card {
			width: 100%;
			max-height: none;
		}

		.match-card {
			width: 100%;
			max-height: none;
		}
	}

	/* Visual separators for purpose checkboxes */
	#purpose_checkboxes .form-check {
		border-bottom: 1px solid #ddd;
		padding-bottom: 8px;
		margin-bottom: 8px;
	}

	#purpose_checkboxes .form-check:last-child {
		border-bottom: none;
		margin-bottom: 0;
	}

	/* Reduce font size for purpose labels by 1 point */
	#purpose_checkboxes .form-check-label {
		font-size: 15px;
	}
</style>
<div class="card shadow-lg">
	<div class="card-body text-center">
		<div class="client-log-container">
			<div class="camera-card shadow-lg rounded">
				<!-- video preview (fills card) -->
				<video id="video" width="420" height="420" autoplay playsinline muted
					style="object-fit:cover; width:420px; height:420px; border-radius:6px; display:none;"></video>

				<!-- placeholder when camera not active -->
				<div id="camera-placeholder" class="text-center text-muted" style="color:#9aa6bc">
					<div style="font-size:44px; opacity:0.5">ðŸ“·</div>
					<div style="margin-top:8px;">Camera Preview</div>
					<h5 class="mt-3" style="color:#9aa6bc; font-weight:600;">Client Log (Face Recognition)</h5>
					<p class="text-muted small" style="color:#9aa6bc;">Capture Client photo and record entry/exit information</p>
				</div>

				<!-- captured preview overlay (inside camera container so absolute sizing is constrained) -->
				<canvas id="canvas" width="420" height="420"
					style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; border-radius:6px;"></canvas>
				<img id="preview" src="" alt="Preview"
					style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; object-fit:contain; border-radius:6px; background:#0f1720;" />
				<div id="scan-line"
					style="display:none; position:absolute; top:0; left:0; width:100%; height:2px; background:linear-gradient(90deg, transparent, rgba(0,255,0,0.8), transparent); z-index:20; animation: scan 2s linear;">
				</div>
				<!-- camera error overlay (shown inside camera container at top) -->
				<div id="camera-error"
					style="display:none; position:absolute; top:10px; left:50%; transform:translateX(-50%); z-index:25; background:rgba(0,0,0,0.6); color:#fff; padding:6px 10px; border-radius:6px; font-weight:600; font-size:0.95rem;">
					No face detected
				</div>
				<!-- camera action button placed inside the camera container -->
				<button id="camera-action" title="Start or control the camera for face recognition" class="btn btn-lg"
					style="position:absolute; bottom:12px; left:50%; transform:translateX(-50%); z-index:10; min-width:140px; background:rgba(0,0,0,0.7); color:white; border:none; border-radius:6px; padding:8px 16px;">Start
					Camera</button>
			</div>

			<!-- Match card -->
			<div class="match-card">
				<!-- Match (Client) card will appear here (always visible) -->
				<div id="result" style="display:block;">
					<div class="card shadow-sm p-3 text-left">
						<p class="mb-1" style="text-align: left;"><strong>Match:</strong> <span id="match_name"
								style="color:red;"></span> <small id="match_gender" class="text-muted"
								style="display:none;"></small> <small id="match_age" class="text-muted"
								style="display:none;"></small></p>
						<div class="mb-2">
							<label class="form-label"><i class="fas fa-question-circle"></i> Purpose *</label>
							<div id="purpose_checkboxes">
								<div class="form-check">
									<input class="form-check-input" type="checkbox" value="Receive Document/s Requested" id="purpose_1">
									<label class="form-check-label" for="purpose_1">Receive Document/s Requested</label>
								</div>
								<div class="form-check">
									<input class="form-check-input" type="checkbox" value="Submit Document/s" id="purpose_2">
									<label class="form-check-label" for="purpose_2">Submit Document/s</label>
								</div>
								<div class="form-check">
									<input class="form-check-input" type="checkbox" value="Request Form/s" id="purpose_3">
									<label class="form-check-label" for="purpose_3">Request Form/s</label>
								</div>
								<div class="form-check">
									<input class="form-check-input" type="checkbox" value="Process Appointment" id="purpose_4">
									<label class="form-check-label" for="purpose_4">Process Appointment</label>
								</div>
								<div class="form-check">
									<input class="form-check-input" type="checkbox" value="Inquire" id="purpose_5">
									<label class="form-check-label" for="purpose_5">Inquire</label>
								</div>
								<div class="form-check">
									<input class="form-check-input" type="checkbox" value="OTHERS" id="purpose_6">
									<label class="form-check-label" for="purpose_6">OTHERS</label>
								</div>
							</div>
						</div>

						<p id="action_msg" class="text-success mt-2" style="display:none;"></p>
					</div>
				</div>
			</div>

			<!-- System log card -->
			<div class="system-log-card">
				<div class="mb-2" id="additional_info_div">
					<label for="additional_info" title="Specific purpose and/or for whom." class="form-label"><i
							class="fas fa-info-circle"></i> Additional Information *</label>
					<input type="text" title="Specific purpose and/or for whom." id="additional_info"
						placeholder="Please specify..." class="form-control">
				</div>
				<div class="d-flex justify-content-center gap-2">
					<button id="time_in" title="Record the client's entry with the selected purpose"
						class="btn btn-success"><i class="fas fa-sign-in-alt"></i> Time In</button>
					<button type="button" title="Use override if you are not identified correctly!"
						class="btn-primary-new" data-bs-toggle="modal" data-bs-target="#overrideModal"><i
							class="fas fa-edit"></i> Override</button>
				</div>
				<hr>
				<h6 class="mb-2">Client Logs</h6>
				<div id="systemLog" style="font-size:0.9rem; line-height:1.25;">Loading...</div>
			</div>
		</div>

		<!-- Override Modal -->
		<div class="modal fade" id="overrideModal" tabindex="-1" aria-labelledby="overrideModalLabel" aria-hidden="true"
			data-bs-backdrop="false">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<h5 class="modal-title" id="overrideModalLabel">Manual Override</h5>
						<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
					</div>
					<div class="modal-body">
						<label for="manual_search" class="form-label mb-1">Search by name or ID (manual
							override)</label>
						<div class="input-group">
							<input type="text" id="manual_search" title="Search for a client by name or client ID"
								class="form-control" placeholder="Type name or ID..." aria-label="Search client"
								autofocus>
							<button id="use_typed" title="Use the entered text as the client identifier"
								class="btn btn-outline-primary" type="button" data-bs-dismiss="modal">Use</button>
						</div>
						<div id="search_suggestions" class="list-group mt-2"
							style="max-height:160px; overflow:auto; display:none;"></div>
						<div class="form-text mt-1">If the camera identifies the wrong person, search and select the
							correct client or press <strong>Use</strong> to accept the typed ID.</div>
					</div>
				</div>
			</div>
		</div>

		<p id="error" style="display:none;" class="text-danger mt-2"></p>
	</div>
</div>
{% endblock %}

{% block scripts %}
<script>
	const video = document.getElementById('video');
	const canvas = document.getElementById('canvas');
	const preview = document.getElementById('preview');
	const scanLine = document.getElementById('scan-line');
	const placeholder = document.getElementById('camera-placeholder');
	const actionBtn = document.getElementById('camera-action');
	const cameraCard = document.querySelector('.camera-card');
	const resultDiv = document.getElementById('result');
	const matchName = document.getElementById('match_name');
	const purposeCheckboxes = document.querySelectorAll('#purpose_checkboxes input[type="checkbox"]');
	const additionalInfoDiv = document.getElementById('additional_info_div');
	const additionalInfoInput = document.getElementById('additional_info');
	const timeInBtn = document.getElementById('time_in');
	const actionMsg = document.getElementById('action_msg');
	const errorP = document.getElementById('error');
	const cameraError = document.getElementById('camera-error');

	function setError(msg) {
		// set page-level error
		errorP.textContent = msg || '';
		if (msg) {
			errorP.style.display = 'block';
		} else {
			errorP.style.display = 'none';
		}
		// show special overlay for face-detection related messages and "No identified client"
		if (!msg) {
			if (cameraError) cameraError.style.display = 'none';
			return;
		}
		const m = String(msg || '');
		// match common face detection phrases, "No identified client", or time-in errors
		if (/no face/i.test(m) || /face not detected/i.test(m) || /no faces?/i.test(m) || /face detected/i.test(m) && /no/i.test(m) || /no identified client/i.test(m) || /please select a purpose/i.test(m) || /please provide additional information/i.test(m)) {
			if (cameraError) { cameraError.textContent = msg; cameraError.style.display = 'block'; }
		} else {
			if (cameraError) cameraError.style.display = 'none';
		}
	}
	// Manual search elements
	const manualSearch = document.getElementById('manual_search');
	const suggestionsBox = document.getElementById('search_suggestions');
	const useTypedBtn = document.getElementById('use_typed');

	// Debounce helper
	function debounce(fn, wait) {
		let t = null;
		return function (...args) {
			clearTimeout(t);
			t = setTimeout(() => fn.apply(this, args), wait);
		};
	}

	// Sound functions using Web Audio API
	function playSuccessSound() {
		try {
			const audioContext = new (window.AudioContext || window.webkitAudioContext)();
			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			oscillator.connect(gainNode);
			gainNode.connect(audioContext.destination);
			oscillator.frequency.setValueAtTime(800, audioContext.currentTime); // Pleasant high frequency
			gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
			oscillator.start(audioContext.currentTime);
			oscillator.stop(audioContext.currentTime + 0.2);
		} catch (e) {
			console.warn('Success sound failed:', e);
		}
	}

	function playErrorSound() {
		try {
			const audioContext = new (window.AudioContext || window.webkitAudioContext)();
			const oscillator = audioContext.createOscillator();
			const gainNode = audioContext.createGain();
			oscillator.connect(gainNode);
			gainNode.connect(audioContext.destination);
			oscillator.frequency.setValueAtTime(200, audioContext.currentTime); // Harsh low frequency
			gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
			gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
			oscillator.start(audioContext.currentTime);
			oscillator.stop(audioContext.currentTime + 0.5);
		} catch (e) {
			console.warn('Error sound failed:', e);
		}
	}

	async function performSearch(q) {
		if (!q || q.length < 1) { suggestionsBox.style.display = 'none'; suggestionsBox.innerHTML = ''; return; }
		try {
			const res = await fetch('/search_client?q=' + encodeURIComponent(q));
			const data = await res.json();
			if (!Array.isArray(data) || data.length === 0) {
				suggestionsBox.style.display = 'none';
				suggestionsBox.innerHTML = '';
				return;
			}
			suggestionsBox.innerHTML = '';
			data.forEach(item => {
				const el = document.createElement('button');
				el.type = 'button';
				el.className = 'list-group-item list-group-item-action';
				el.textContent = (item.full_name ? item.full_name + ' â€” ' : '') + item.client_id;
				el.dataset.clientId = item.client_id;
				el.dataset.fullName = item.full_name || '';
				el.setAttribute('data-bs-dismiss', 'modal');
				el.addEventListener('click', () => {
					// pick this suggestion
					currentClientId = el.dataset.clientId;
					matchName.textContent = el.dataset.fullName || el.dataset.clientId;
					resultDiv.style.display = 'block';
					actionMsg.style.display = 'none';
					purposeCheckboxes.forEach(cb => cb.disabled = false);
					suggestionsBox.style.display = 'none';
				});
				suggestionsBox.appendChild(el);
			});
			suggestionsBox.style.display = 'block';
		} catch (err) {
			console.error('Search failed', err);
			suggestionsBox.style.display = 'none';
		}
	}

	const debouncedSearch = debounce((e) => performSearch(e.target.value.trim()), 250);

	if (manualSearch) {
		manualSearch.addEventListener('input', debouncedSearch);
		manualSearch.addEventListener('keydown', (e) => {
			if (e.key === 'Enter') {
				e.preventDefault();
				// if suggestions visible, pick first; otherwise use typed
				const first = suggestionsBox.querySelector('button');
				if (first) { first.click(); }
				else { useTyped(); }
			}
		});
	}

	function useTyped() {
		const v = manualSearch && manualSearch.value && manualSearch.value.trim();
		if (!v) { errorP.textContent = 'Please type an ID or name before using.'; return; }
		// use the typed value as client_id (logs accept any string)
		currentClientId = v;
		matchName.textContent = v;
		resultDiv.style.display = 'block';
		actionMsg.style.display = 'none';
		suggestionsBox.style.display = 'none';
		// Close the modal
		const modal = document.getElementById('overrideModal');
		const bsModal = bootstrap.Modal.getInstance(modal);
		if (bsModal) bsModal.hide();
	}

	if (useTypedBtn) useTypedBtn.addEventListener('click', useTyped);

	// Additional info is always visible for all purposes

	function stopCamera() {
		if (stream) {
			stream.getTracks().forEach(t => t.stop());
			stream = null;
		}
		video.srcObject = null;
		video.style.display = 'none';
		placeholder.style.display = 'block';
		preview.style.display = 'none';
		canvas.style.display = 'none';
		cameraState = 'stopped';
		actionBtn.textContent = 'Start Camera';
	}

	let stream = null;
	let currentClientId = null;
	let cameraState = 'stopped'; // 'stopped' | 'started' | 'captured'
	let lastPurpose = null;

	// Camera action function
	async function cameraAction() {
		setError('');
		if (cameraState === 'stopped') {
			// start camera
			try {
				stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
				console.log('Stream obtained:', stream);
				video.srcObject = stream;
				await video.play(); // Ensure video starts playing
				console.log('Video playing, dimensions:', video.videoWidth, 'x', video.videoHeight);
				video.style.display = 'block';
				placeholder.style.display = 'none';
				cameraState = 'started';
				actionBtn.textContent = 'SCAN';
				setError('');
			} catch (err) {
				console.error('Camera error:', err);
				setError('Could not start camera: ' + err.message);
			}
			return;
		}

		if (cameraState === 'started') {
			// capture
			if (!stream) { setError('Start the camera first'); return; }
			const ctx = canvas.getContext('2d');
			// Calculate the visible area in video coordinates to match object-fit: cover
			const containerW = 420;
			const containerH = 420;
			const vw = video.videoWidth || 420;
			const vh = video.videoHeight || 420;
			const scale = Math.max(containerW / vw, containerH / vh);
			const scaledW = vw * scale;
			const scaledH = vh * scale;
			let sourceX = 0, sourceY = 0, sourceW = vw, sourceH = vh;
			if (scaledW > containerW) {
				// crop horizontally
				const cropAmount = (scaledW - containerW) / scale;
				sourceX = cropAmount / 2;
				sourceW = vw - cropAmount;
			} else {
				// crop vertically
				const cropAmount = (scaledH - containerH) / scale;
				sourceY = cropAmount / 2;
				sourceH = vh - cropAmount;
			}
			// Set canvas size to the cropped visible area, then scale down if needed
			let targetW = sourceW;
			let targetH = sourceH;
			const MAX_W = 800;
			if (targetW > MAX_W) {
				const scaleDown = MAX_W / targetW;
				targetW = Math.round(targetW * scaleDown);
				targetH = Math.round(targetH * scaleDown);
			}
			canvas.width = targetW;
			canvas.height = targetH;
			// Draw only the visible cropped part
			ctx.drawImage(video, sourceX, sourceY, sourceW, sourceH, 0, 0, targetW, targetH);
			// encode as JPEG (quality 0.9)
			const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
			preview.src = dataUrl;
			preview.style.display = 'block';
			scanLine.style.display = 'block';
			// Reset animation to restart on each capture
			scanLine.style.animation = 'none';
			setTimeout(() => {
				scanLine.style.animation = 'scan 2s linear';
			}, 10);
			canvas.style.display = 'none'; // keep canvas hidden; we use it only for capture
			// show captured overlay and hide live video
			video.style.display = 'none';
			// Ensure preview uses contain to avoid any stretching
			preview.style.objectFit = 'contain';
			cameraState = 'captured';
			actionBtn.textContent = 'Stop Camera';

			// send to server for identification
			const fd = new FormData();
			fd.append('photo_data', dataUrl);
			try {
				const res = await fetch('/identify', { method: 'POST', body: fd });
				const body = await res.json();
				if (body.ok) {
					playSuccessSound(); // Play success sound on successful identification
					currentClientId = body.client_id;
					matchName.textContent = body.full_name || '(no name)';
					const mg = document.getElementById('match_gender');
					if (mg) mg.textContent = body.gender ? ('â€¢ ' + body.gender) : '';
					const ma = document.getElementById('match_age');
					if (ma) ma.textContent = body.age ? ('â€¢ ' + body.age) : '';
					resultDiv.style.display = 'block';
					actionMsg.style.display = 'none';
					purposeCheckboxes.forEach(cb => cb.disabled = false);
				} else {
					playErrorSound(); // Play error sound on failed identification
					// keep match card visible but indicate no match so operator can use manual override
					setError(body.error || 'No match');
					currentClientId = null;
					matchName.textContent = '(no match)';
					const mg = document.getElementById('match_gender'); if (mg) mg.textContent = '';
					const ma = document.getElementById('match_age'); if (ma) ma.textContent = '';
					resultDiv.style.display = 'block';
					actionMsg.style.display = 'none';
				}
			} catch (err) {
				setError('Identification failed: ' + err.message);
				currentClientId = null;
				matchName.textContent = '(no match)';
				const mg = document.getElementById('match_gender'); if (mg) mg.textContent = '';
				const ma = document.getElementById('match_age'); if (ma) ma.textContent = '';
				resultDiv.style.display = 'block';
			}
			return;
		}

		if (cameraState === 'captured') {
			// stop camera and reset
			if (stream) {
				stream.getTracks().forEach(t => t.stop());
				stream = null;
			}
			video.srcObject = null;
			video.style.display = 'none';
			placeholder.style.display = 'block';
			preview.style.display = 'none';
			canvas.style.display = 'none';
			cameraState = 'stopped';
			actionBtn.textContent = 'Start Camera';
			return;
		}
	}

	// Combined camera button handler
	actionBtn.addEventListener('click', cameraAction);

	// Make the entire camera card clickable
	if (cameraCard) {
		cameraCard.addEventListener('click', (e) => {
			// Prevent triggering if clicking on the button itself to avoid double execution
			if (e.target === actionBtn) return;
			cameraAction();
		});
	}

	async function sendLog(action) {
		if (!currentClientId) { setError('No identified client'); playErrorSound(); return; }
		// For time_in we send purposes; for time_out we do NOT include/modify purpose (purpose preserved from time_in)
		let purposes = [];
		if (action === 'time_in') {
			purposeCheckboxes.forEach(cb => {
				if (cb.checked) purposes.push(cb.value);
			});
		}
		const additionalInfo = additionalInfoInput.value.trim();
		if (action === 'time_in') {
			if (purposes.length === 0) {
				setError('Please select at least one purpose.');
				playErrorSound();
				return;
			}
			if (!additionalInfo) {
				setError('Please provide additional information.');
				playErrorSound();
				return;
			}
		}
		try {
			const res = await fetch('/log_action', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ client_id: currentClientId, action, purposes, additional_info: additionalInfoInput.value || null })
			});
			const body = await res.json();
			if (body.ok) {
				playSuccessSound(); // Play success sound on successful time in/out
				if (action === 'time_out') {
					actionMsg.textContent = 'Time out recorded';
					actionMsg.style.display = 'block';
				}
				setError('');
				if (action === 'time_in') lastPurpose = purposes.join(', ') || null;
				// after time_in, clear current match and reset form fields
				if (action === 'time_in') {
					currentClientId = null;
					// clear the match card displayed values
					matchName.textContent = '';
					const mg = document.getElementById('match_gender'); if (mg) mg.textContent = '';
					const ma = document.getElementById('match_age'); if (ma) ma.textContent = '';
					purposeCheckboxes.forEach(cb => cb.checked = false);
					additionalInfoInput.value = '';
					lastPurpose = null;
					// clear the captured image and reset camera
					stopCamera();
				}
				// after time_out, clear current match and reset purpose input
				if (action === 'time_out') {
					currentClientId = null;
					// keep the match card visible but clear the displayed values so operator can use manual search
					matchName.textContent = '';
					const mg = document.getElementById('match_gender'); if (mg) mg.textContent = '';
					const ma = document.getElementById('match_age'); if (ma) ma.textContent = '';
					purposeCheckboxes.forEach(cb => cb.disabled = false);
					purposeCheckboxes.forEach(cb => cb.checked = false);
					additionalInfoInput.value = '';
					lastPurpose = null;
				}

				// refresh the Today's Logs panel immediately so operator sees the update
				if (typeof refreshTodayLogs === 'function') {
					try { refreshTodayLogs(); } catch (e) { console.warn('refreshTodayLogs failed', e); }
				}
			} else {
				playErrorSound(); // Play error sound on failed logging
				errorP.textContent = body.error || 'Failed to record log';
			}
		} catch (err) {
			playErrorSound(); // Play error sound on logging failure
			errorP.textContent = 'Logging failed: ' + err.message;
		}
	}

	timeInBtn.addEventListener('click', () => sendLog('time_in'));

	// Fetch and show system logs (only logged-in clients) in the right-side div
	async function refreshTodayLogs() {
		const el = document.getElementById('systemLog');
		if (!el) return;
		try {
			const res = await fetch('/today_logs');
			const data = await res.json();
			if (!Array.isArray(data)) {
				el.innerHTML = '<div class="text-muted">Error loading logs</div>';
				return;
			}
			if (data.length === 0) {
				el.innerHTML = '<div class="text-muted">No active clients.</div>';
				return;
			}
			// Create list items for each logged-in client
			el.innerHTML = '';
			data.forEach(r => {
				const item = document.createElement('div');
				item.className = 'd-flex justify-content-between align-items-center mb-2 p-2 border rounded';

				const name = r.full_name || r.client_id;
				const timeIn = r.time_in ? new Date(r.time_in).toLocaleTimeString() : 'Unknown';
				const purpose = r.purpose || '';
				item.innerHTML = `
				<div class="d-flex flex-column align-items-start" style="text-align: left;">
					<strong>${name}</strong>
					<small class="text-muted" style="text-align: left;"><span class="text-success">In: ${timeIn}</span> | <span class="text-primary">${purpose}</span></small>
				</div>
				<button class="btn btn-sm btn-outline-danger" title="Logout this client" onclick="logoutClient('${r.client_id}')">Logout</button>
			`;
				el.appendChild(item);
			});
		} catch (err) {
			el.innerHTML = '<div class="text-danger">Failed to load logs: ' + err.message + '</div>';
		}
	}

	// Logout a specific client
	async function logoutClient(clientId) {
		try {
			const res = await fetch('/logout_client/' + encodeURIComponent(clientId), { method: 'POST' });
			const body = await res.json();
			if (body.ok) {
				// Refresh the logs
				refreshTodayLogs();
			} else {
				alert('Failed to logout client: ' + (body.error || 'Unknown error'));
			}
		} catch (err) {
			alert('Logout failed: ' + err.message);
		}
	}

	// initial load and periodic refresh
	refreshTodayLogs();
	setInterval(refreshTodayLogs, 10000);

	// Ensure modal input gets focus when modal opens
	document.getElementById('overrideModal').addEventListener('shown.bs.modal', function () {
		document.getElementById('manual_search').focus();
	});


</script>
{% endblock %}